#pragma kernel BeginFrame
#pragma kernel GenerateTestLines
#pragma kernel DrawDispatchArgs
#pragma kernel UpdateAndDrawPlayer
#pragma kernel UpdateAndDrawAsteroid
#pragma kernel UpdateAndDrawBullet
#pragma kernel CollidePlayerAsteroid
#pragma kernel CollideBulletAsteroid
#pragma kernel BuildFont
#pragma kernel DrawFont
#pragma kernel UpdateGame
#pragma kernel SetupDispatch
#pragma kernel ClearAsteroids
#pragma kernel SpawnAsteroids

//structures
struct Line {
    float2 a;
    float2 b;
};
struct Character {
    float2 pos;
    float2 scl;
    int id;
};

struct Globals {
    int numLines;
    int numCharacters;

    int nextBullet;
    int nextAsteroid;
    int numSoundRequests;
    int gameMode;

    int requestClearAsteroids;
    int requestSpawnAsteroids;
};
struct KeyState {
    int down;
    int pressed;
    int released;
};
struct PlayerState {
    float2 position;
    float rotation;
    float2 velocity;
    int alive;
    int waitingToSpawn;
};
struct AsteroidState {
    float2 position;
    float rotation;
    float2 velocity;
    int alive;
    float radius;
    int level;
};
struct BulletState {
    float2 position;
    float2 velocity;
    float lifetime;
};
struct SoundRequest {
    int id;
};

#include "Font.cginc"

//matching ids of sounds loaded in game.cs
#define SND_FIRE 0
#define SND_EXPLODE 1
#define SND_BLOB 2

//special key codes (that aren't just ascii codes)
#define KEY_ESCAPE 0

//kernel ids for indirect dispatching
#define KID_SPAWN_ASTEROIDS 0
#define KID_CLEAR_ASTEROIDS 1

//buffers
RWStructuredBuffer<Line> _linesRW;
RWStructuredBuffer<Character> _charactersRW;
RWStructuredBuffer<Globals> _globals;
RWStructuredBuffer<uint> _dispatch;
StructuredBuffer<KeyState> _keyStates;
StructuredBuffer<Line> _font;
RWStructuredBuffer<PlayerState> _playersRW;
RWStructuredBuffer<AsteroidState> _asteroidsRW;
RWStructuredBuffer<BulletState> _bulletsRW;
RWStructuredBuffer<SoundRequest> _soundRequestsRW;

//general use uniform to limit dispatch thread counts
int _threadCount;

//time step and time from unity
float _timeStep;
float _time;
int _frame;

//buffer info
int _maxBullets;
int _maxAsteroids;
int _maxPlayers;
int _maxSoundRequests;

//used by dispatch setup
int _kernelIdRequested;

//single dispatch to reset line counter
[numthreads(1,1,1)]
void BeginFrame(uint3 id : SV_DispatchThreadID)
{
    _globals[0].numLines = 0;
    _globals[0].numCharacters = 0;
    _globals[0].numSoundRequests = 0;
}

//creates lines based on dispatch thread
[numthreads(256, 1, 1)]
void GenerateTestLines(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _threadCount)
    {
        //allocate space
        int lineIdx;
        InterlockedAdd(_globals[0].numLines, 1, lineIdx);

        //build line
        Line l;
        float ang = radians(id.x*2);
        float3 dir = float3(sin(ang), cos(ang), 0);
        l.a = float2(1024, 768) * 0.5;
        l.b = float2(1024,768) * 0.5 + dir * 0.5 * 768;
        _linesRW[lineIdx] = l;
    }
}

//fills out indirect dispatch args 
[numthreads(1, 1, 1)]
void DrawDispatchArgs(uint3 id : SV_DispatchThreadID)
{
    _dispatch[0] = _globals[0].numLines*2; //v count per inst (2 verts per line)
    _dispatch[1] = 1; //1 instance
    _dispatch[2] = 0; //verts start at 0
    _dispatch[3] = 0; //instances start at 0

    _dispatch[4] = _globals[0].numCharacters * 2 * LINES_PER_CHARACTER; //v count per inst (2 verts per line per character)
    _dispatch[5] = 1; //1 instance
    _dispatch[6] = 0; //verts start at 0
    _dispatch[7] = 0; //instances start at 0
}

int AllocLines(int count) {
    int lineIdx;
    InterlockedAdd(_globals[0].numLines, count, lineIdx);
    return lineIdx;
}
void AddLine(int idx, float2 a, float2 b) {
    _linesRW[idx].a = a;
    _linesRW[idx].b = b;
}

void PlaySound(int id) {
    int idx;
    InterlockedAdd(_globals[0].numSoundRequests, 1, idx);
    if (idx < _maxSoundRequests) {
        _soundRequestsRW[idx].id = id;
    }
}

float2 mulpoint(float3x3 trans, float2 p) {
    return mul(trans, float3(p, 1)).xy;
}
float2 mulvec(float3x3 trans, float2 p) {
    return mul(trans, float3(p, 0)).xy;
}

//some random functions
uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
float wang_rand(uint seed)
{
    uint res = wang_hash(seed);
    float rf = (res % 256);
    return rf / 255;
}
float wang_rand(float val)
{
    uint hash_val = (uint)(val * 100);
    uint res = wang_hash(hash_val);
    float rf = (res % 256);
    return rf / 255;
}
float permute(float2 val)
{
    return wang_rand(val.y + wang_rand(val.x));
}
float permute(float3 val)
{
    return wang_rand(val.z + wang_rand(val.y + wang_rand(val.x)));
}

//updates player movement and outputs draw request
[numthreads(256, 1, 1)]
void UpdateAndDrawPlayer(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _threadCount)
    {
        PlayerState player = _playersRW[id.x];
        if(player.alive) {
            float rot = 0;
            float thrust = 0;
            float rotPerSecond = 3.5;
            float thrustPerSecond = 150;

            if (_keyStates['a'].down) {
                rot -= rotPerSecond * _timeStep;
            }
            if (_keyStates['d'].down) {
                rot += rotPerSecond * _timeStep;
            }
            if (_keyStates['w'].down) {
                thrust += thrustPerSecond * _timeStep;
            }
            if (_keyStates['r'].pressed) { //handy debug reset
                player.velocity = 0;
                player.position = float2(1024, 768)*0.5f;
                player.rotation = 0;
            }

            //wrap player (note: better version should handle overshoot amount)
            player.position = player.position >= 0 ? player.position : float2(1024, 768);
            player.position = player.position <= float2(1024,768) ? player.position  : 0;
            player.rotation += rot;

            float2 worldy = float2(sin(player.rotation), cos(player.rotation));
            float2 worldx = float2(-worldy.y, worldy.x);

            player.velocity += worldy * thrust;
            player.position += player.velocity * _timeStep;

            if (_keyStates[' '].pressed) {
                int nextBullet;
                InterlockedAdd(_globals[0].nextBullet, 1, nextBullet);
                BulletState b;
                b.position = player.position;
                b.velocity = worldy * 1000;
                b.lifetime = 3;
                _bulletsRW[nextBullet%_maxBullets] = b;
                PlaySound(SND_FIRE);
            }


            float scl = 12;
            //float scl = 50;

            worldx *= scl;
            worldy *= scl;
            float3x3 trans = {
                worldx.x, worldy.x, player.position.x,
                worldx.y, worldy.y, player.position.y,
                0, 0, 1
            };

            int lineIdx = AllocLines(5);
            
            float2 leftcorner = mulpoint(trans, float2(-0.7, -1));
            float2 rightcorner = mulpoint(trans, float2(0.7, -1));
            float2 tip = mulpoint(trans, float2(0, 1));
            float2 leftback = mulpoint(trans, float2(-0.3, -0.7f));
            float2 rightback = mulpoint(trans, float2(0.3, -0.7f));

            AddLine(lineIdx++, leftcorner, tip);
            AddLine(lineIdx++, rightcorner, tip);
            AddLine(lineIdx++, leftcorner, leftback);
            AddLine(lineIdx++, rightcorner, rightback);
            AddLine(lineIdx++, leftback, rightback);

            int thrustframe = (_frame / 4);
            if (thrust > 0 && (thrustframe &1)) {
                lineIdx = AllocLines(2);
                float2 thrustback = mulpoint(trans, float2(0.0f, -1.5f-wang_rand(thrustframe)*0.15f));
                AddLine(lineIdx++, leftback, thrustback);
                AddLine(lineIdx++, rightback, thrustback);
            }             
        }
        _playersRW[id.x] = player;
    }
}

//updates player movement and outputs draw request
[numthreads(256, 1, 1)]
void UpdateAndDrawAsteroid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _threadCount)
    {
        AsteroidState asteroid = _asteroidsRW[id.x];
        if (asteroid.alive) {

            asteroid.position += asteroid.velocity * _timeStep;
            asteroid.position = asteroid.position >= 0 ? asteroid.position : float2(1024, 768);
            asteroid.position = asteroid.position <= float2(1024, 768) ? asteroid.position : 0;

            float scl = asteroid.radius;

            float2 worldy = float2(sin(asteroid.rotation), cos(asteroid.rotation));
            float2 worldx = float2(-worldy.y, worldy.x);
            worldx *= scl;
            worldy *= scl;
            float3x3 trans = {
                worldx.x, worldy.x, asteroid.position.x,
                worldx.y, worldy.y, asteroid.position.y,
                0, 0, 1
            };

            //alloc edges
            const int NUM_EDGES = 9;
            int lineIdx = AllocLines(NUM_EDGES);

            //build first point then start iterating
            float randscl = 0.75f;
            float2 first;
            {
                int i = 0;
                float ang = 0;
                float2 pos = float2(sin(ang), cos(ang));
                pos += randscl * float2(wang_rand(id.x*NUM_EDGES + i), wang_rand(id.x*NUM_EDGES * 2 + i));
                first = mulpoint(trans, pos);
            }
            float2 prev = first;
            for (int i = 1; i < NUM_EDGES; i++) {

                //offset every other point using random number
                float ang = (i*3.1415927f*2.0f) / NUM_EDGES;
                float2 pos = float2(sin(ang), cos(ang));
                pos += randscl * float2(wang_rand(id.x*NUM_EDGES + i), wang_rand(id.x*NUM_EDGES * 2 + i));

                //add new line
                float2 curr = mulpoint(trans, pos);
                AddLine(lineIdx++, prev, curr); 
                prev = curr;
            }

            //add final line to joinn previous point to first point
            AddLine(lineIdx++, prev, first);

        }
        _asteroidsRW[id.x] = asteroid;
    }
}

//updates player movement and outputs draw request
[numthreads(256, 1, 1)]
void UpdateAndDrawBullet(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _threadCount)
    {
        BulletState bullet = _bulletsRW[id.x];
        if (bullet.lifetime > 0) {

            bullet.position += bullet.velocity * _timeStep;
            if (any(bullet.position < 0) || any(bullet.position > float2(1024, 768))) {
                bullet.lifetime = -1;
                return;
            }
            bullet.lifetime -= _timeStep;

            float scl = 2;
            float3x3 trans = {
                scl, 0, bullet.position.x,
                0, scl, bullet.position.y, 
                0, 0, 1
            };

            //alloc edges
            const int NUM_EDGES = 6;
            int lineIdx = AllocLines(NUM_EDGES);

            //build first point then start iterating
            float2 first;
            {
                int i = 0;
                float ang = 0;
                float2 pos = float2(sin(ang), cos(ang));
                first = mulpoint(trans, pos);
            }
            float2 prev = first;
            for (int i = 1; i < NUM_EDGES; i++) {

                float ang = (i*3.1415927f*2.0f) / NUM_EDGES;
                float2 pos = float2(sin(ang), cos(ang));
                float2 curr = mulpoint(trans, pos);
                AddLine(lineIdx++, prev, curr);
                prev = curr;
            }

            //add final line to joinn previous point to first point
            AddLine(lineIdx++, prev, first);

        }
        _bulletsRW[id.x] = bullet;
    }
}

void SplitAsteroid(int idx) {
    int nextIndex;
    InterlockedAdd(_globals[0].nextAsteroid, 2, nextIndex);
    nextIndex = nextIndex % _maxAsteroids;

    PlaySound(SND_EXPLODE);
    
    AsteroidState asteroid = _asteroidsRW[idx];
    if (asteroid.level < 2) {

        float childSpeed = 50; 

        AsteroidState child;
        child.position = asteroid.position;
        child.velocity = asteroid.velocity + (float2(wang_rand(nextIndex), wang_rand(nextIndex * 2)) * 2 - 1) * childSpeed;
        child.alive = 1;
        child.radius = asteroid.radius * 0.5;
        child.rotation = (wang_rand(nextIndex * 3) * 2 - 1) * 3.1415927f;
        child.level = asteroid.level + 1;
        _asteroidsRW[nextIndex++] = child;
        nextIndex = nextIndex % _maxAsteroids;

        child.position = asteroid.position;
        child.velocity = asteroid.velocity + (float2(wang_rand(nextIndex), wang_rand(nextIndex * 2)) * 2 - 1) * childSpeed;
        child.alive = 1;
        child.radius = asteroid.radius * 0.5;
        child.rotation = (wang_rand(nextIndex * 3) * 2 - 1) * 3.1415927f;
        child.level = asteroid.level + 1;
        _asteroidsRW[nextIndex++] = child;
        nextIndex = nextIndex % _maxAsteroids;
    }


    _asteroidsRW[idx].alive = 0;
}

[numthreads(256, 1, 1)]  
void CollidePlayerAsteroid(uint3 id : SV_DispatchThreadID) 
{
    if (id.x < _threadCount)
    {
        int playerIdx = id.x / _maxAsteroids;
        int asteroidIdx = id.x - (playerIdx*_maxAsteroids);

        PlayerState player = _playersRW[playerIdx];
        AsteroidState asteroid = _asteroidsRW[asteroidIdx];

        if (player.alive && asteroid.alive) {
            if (length(player.position - asteroid.position) < (asteroid.radius+10)) {
                _playersRW[playerIdx].alive = 0;
                SplitAsteroid(asteroidIdx);
            }
        }
    }
}

[numthreads(256, 1, 1)]
void CollideBulletAsteroid(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _threadCount)
    {
        int bulletIdx = id.x / _maxAsteroids;
        int asteroidIdx = id.x - (bulletIdx*_maxAsteroids);

        BulletState bullet = _bulletsRW[bulletIdx];
        AsteroidState asteroid = _asteroidsRW[asteroidIdx];

        if (bullet.lifetime > 0 && asteroid.alive) {
            if (length(bullet.position - asteroid.position) < (asteroid.radius + 2)) {
                _bulletsRW[bulletIdx].lifetime = -1;
                SplitAsteroid(asteroidIdx);
            }
        }
    }
}

//expected to dispatch 1 group, resulting in 256 calls, 1 for each potential ascii character
[numthreads(256, 1, 1)]
void BuildFont(uint3 id : SV_DispatchThreadID)
{
    BuildCharacter(id.x);
}
[numthreads(256, 1, 1)]
void DrawFont(uint3 id : SV_DispatchThreadID)
{
    int lineIdx = AllocLines(LINES_PER_CHARACTER);
    int charOffset = id.x * LINES_PER_CHARACTER;

    float2 pos = float2(id.x / 16, id.x % 16) * float2(20,25) + 100;
    float2 scl = float2(15,20);

    for (int i = 0; i < LINES_PER_CHARACTER; i++) {
        float2 a = _font[charOffset + i].a * scl + pos;
        float2 b = _font[charOffset + i].b * scl + pos;
        AddLine(lineIdx++, a, b);
    }
}

int AllocCharacters(int count) {
    int idx;
    InterlockedAdd(_globals[0].numCharacters, count, idx);
    return idx;
}
void DrawCharacter(int idx, int code, float2 pos, float2 scl) {
    Character c;
    c.id = code;
    c.pos = pos;
    c.scl = scl;
    _charactersRW[idx] = c;
}

void DrawText_OneCoinOnePlay() {
    float2 pos = float2(350,150);
    float2 scl = float2(18, 20);
    float2 spacing = float2(scl.x*1.25, 0);

    int idx = AllocCharacters(13);
    DrawCharacter(idx++, '1', pos, scl); pos += spacing;
    DrawCharacter(idx++, ' ', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'C', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'O', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'I', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'N', pos, scl); pos += spacing;
    DrawCharacter(idx++, ' ', pos, scl); pos += spacing;
    DrawCharacter(idx++, '1', pos, scl); pos += spacing;
    DrawCharacter(idx++, ' ', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'P', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'L', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'A', pos, scl); pos += spacing;
    DrawCharacter(idx++, 'Y', pos, scl); pos += spacing;
}

void DrawNumberTimes10(int number, float2 pos, float2 scl, bool pad) {
    float2 spacing = float2(scl.x*1.25, 0);

    int idx = AllocCharacters(8);

    bool onFirstChar = true;
    for (int base = 1000000; base > 0; base /= 10) {
        int val = clamp(number / base,0,9);
        number -= val * base;
        if (val != 0 || !onFirstChar || base==1) {
            //output character
            DrawCharacter(idx++, '0'+val, pos, scl); pos += spacing;
            onFirstChar = false;
        }
        else {
            //output space and increment pos if padding requested
            DrawCharacter(idx++, ' ', pos, scl);
            if(pad)
                pos += spacing;
        }
    }

    //final 0
    DrawCharacter(idx++, '0', pos, scl); pos += spacing;
}

[numthreads(1,1,1)]
void SetupDispatch(uint3 id: SV_DispatchThreadID)
{
    switch (_kernelIdRequested) {
    case KID_CLEAR_ASTEROIDS: {
        _dispatch[0] =  _globals[0].requestClearAsteroids ? (_maxAsteroids+255)/256 : 0;
        break;
    }
    case KID_SPAWN_ASTEROIDS: {
        _dispatch[0] = (_globals[0].requestSpawnAsteroids + 255) / 256;
        break;
    }
    default: {
        _dispatch[0] = 0; 
        break;
    }
    }
    _dispatch[1] = 1;
    _dispatch[2] = 1;
}

[numthreads(1,1,1)]
void UpdateGame(uint3 id : SV_DispatchThreadID)
{
    DrawNumberTimes10(0, float2(100, 700), float2(18, 20), true);
    DrawNumberTimes10(0, float2(800, 700), float2(18, 20), false);
    DrawNumberTimes10(0, float2(500, 680), float2(18, 20)*0.75, false);

    int gameMode = _globals[0].gameMode;
    if (gameMode == 0) {
        //on init, ask for 8 asteroids to move around in the background
        gameMode = 1;
        _globals[0].requestSpawnAsteroids = 8;
    }
    else if (gameMode == 1)
    { 
        //main menu
        DrawText_OneCoinOnePlay();

        //when 'c' is pressed, ask to clear and then spawn 4 new asteroids
        if (_keyStates['c'].pressed) {
            _globals[0].requestClearAsteroids = true;
            _globals[0].requestSpawnAsteroids = 4;
            gameMode = 2;
        }
    }
    _globals[0].gameMode = gameMode;
}

[numthreads(256, 1, 1)]
void ClearAsteroids(uint3 id : SV_DispatchThreadID) {
    _globals[0].requestClearAsteroids = 0;
    _globals[0].nextAsteroid = 0;
    if (id.x < _maxAsteroids)
    {
        _asteroidsRW[id.x].alive = 0;
    }
}

[numthreads(256,1,1)] 
void SpawnAsteroids(uint3 id : SV_DispatchThreadID) {
    int maxCount = _threadCount < 0 ? _globals[0].requestSpawnAsteroids : _threadCount;
    _globals[0].requestSpawnAsteroids = 0;
    if (id.x < maxCount)
    { 
        int nextIndex;
        InterlockedAdd(_globals[0].nextAsteroid, 1, nextIndex);
        nextIndex = nextIndex % _maxAsteroids;

        AsteroidState asteroid;

        uint hash = wang_hash(id.x + _frame + 128312631);

        uint xhash = wang_hash(hash);
        uint yhash = wang_hash(xhash);

        float x = (xhash % 1024);
        float y = (yhash % 768);

        asteroid.position = float2(x, y);

        uint xvelhash = wang_hash(yhash);
        uint yvelhash = wang_hash(xvelhash);

        float xvel = (xvelhash % 100)-50.0f;
        float yvel = (yvelhash % 100)-50.0f;

        asteroid.velocity = float2(xvel, yvel);
        asteroid.alive = 1;
        asteroid.radius = 30.0f;
        asteroid.rotation = radians(wang_hash(yvelhash) % 360);
        asteroid.level = 0;
        _asteroidsRW[nextIndex] = asteroid;
    }
}

